@static {
    create {
        return true;
    }
    delete_on_close = true;
}

public principal playerW;
public principal playerB;
public string currentPlayer = "w";
public string gameState = "waiting";

bubble playerColor = playerW == @who ? "w" : "d";

enum PieceType {
    None,
    Pawn,
    Knight,
    Bishop,
    Rook,
    Queen,
    King,

}

record Piece {
    PieceType pieceInfo;
    string color = "n";
    bool twice = true;
    bool canCastle = false;
    bool canTakeFromEnPassant = false;
    method resetPiece() {
        pieceInfo = PieceType::None;
        color = "n";
        twice = true;
        canCastle = false;
        canTakeFromEnPassant = false;
    }
    method setPieceInfo(string _color, bool _twice, bool _canCastle, bool _canTakeFromEnPessant, PieceType _pieceInfo) {
        pieceInfo = _pieceInfo;
        color = _color;
        twice = _twice;
        canCastle = _canCastle;
        canTakeFromEnPassant = _canTakeFromEnPessant;
    }
    

}
record BoardSquare {
    int rank;
    int file;
    Piece piece;

}


table<BoardSquare> _chessBoard;
public formula chessBoard = iterate _chessBoard;
public string PLEASE;
@construct {
    for (int row = 0; row < 8; row++ ) {
        for (int column = 0; column < 8; column++ ) {
            _chessBoard <- {rank: row, file: column, piece: {pieceInfo: PieceType::None}};
            
            
        }
    }
    /* Initial board */
    (iterate _chessBoard where rank == 6 || rank == 1).piece.pieceInfo = PieceType::Pawn;
    (iterate _chessBoard where rank == 0 || rank == 1).piece.color = "b";
    (iterate _chessBoard where rank == 7 || rank == 6).piece.color = "w";
    (iterate _chessBoard where (rank == 7 || rank==0) && (file==0 || file == 7)).piece.pieceInfo = PieceType::Rook;
    (iterate _chessBoard where (rank == 7 || rank==0) && (file==1 || file == 6)).piece.pieceInfo = PieceType::Knight;
    (iterate _chessBoard where (rank == 7 || rank==0) && (file==2 || file == 5)).piece.pieceInfo = PieceType::Bishop;
    (iterate _chessBoard where (rank == 7 || rank==0) && (file == 3 )).piece.pieceInfo = PieceType::Queen;
    (iterate _chessBoard where (rank == 7 || rank==0) && (file == 4)).piece.pieceInfo = PieceType::King;

}
message playerSquare {
    int fromRank;
    int toRank;

    int fromFile;
    int toFile;

}

function posToIndex(int file, int rank) -> int {
    return rank * 8 + file;
}

public string lastMove;
public string NONO;
public int piecetype;
/* Break up Valid Functions into seperate based on item */
procedure isMoveValid( int fromRow, int fromCol, int toRow, int toCol, Piece fromPiece) -> bool {
    int size = 0;
    list<BoardSquare> inFront;
    int multiplier = fromPiece.color == "b" ? -1 : 1;
    
    if (fromRow == toRow && toCol == fromCol) {
        return false;
    }
    if ((iterate _chessBoard where (fromRow == rank && fromCol == file) || (toCol == file && toRow == rank) limit 2).size() != 2) {
        return false;
    }

    
    if (fromPiece.pieceInfo == PieceType::Pawn) {
        
        if (toCol != fromCol) {
            /* Check if can take diagonals */
            if( (fromCol + 1 == toCol && fromRow - multiplier == toRow && (iterate _chessBoard where file == fromCol +1 && rank == fromRow - multiplier && piece.pieceInfo != PieceType::None limit 1).size() == 1)||  (fromCol - 1 == toCol && fromRow - multiplier == toRow && (iterate _chessBoard where file == fromCol - 1 && rank == fromRow - multiplier && piece.pieceInfo != PieceType::None limit 1).size() == 1)) {
                return true;
            }
            return false;
        }
        
        /*Find first item in front */
        if (multiplier == 1) {
            inFront = iterate _chessBoard where (rank < fromRow && file == fromCol && piece.pieceInfo != PieceType::None) order by rank desc limit 1;
        } else {
            inFront = iterate _chessBoard where (rank > fromRow && file == fromCol && piece.pieceInfo != PieceType::None) order by rank asc limit 1;
        }
        size = inFront.size();
        if (size == 1)  {
            if (inFront[0] as frontItem) {
                if (multiplier == 1) {
                    if (toRow <= frontItem.rank) {
                        return false;
                    }
                } else {
                    if (toRow >= frontItem.rank) {
                        return false;
                    }
                }
            }
        }
        
        /* Pawns have interesting properties, so it would be important to update it when they use their properties */
        if (fromPiece.twice && (toRow == fromRow - (multiplier * 2))) {
            return true;
        } else {
            if (toRow == fromRow - (multiplier)) {
                return true;
            } else {
                return false;
            }

        }
    }
    /* Knight has specific pattern, and it does not matter for color */
    if (fromPiece.pieceInfo == PieceType::Knight) {
        int firstPos = posToIndex(toCol, toRow);
        int secondPos = posToIndex(fromCol, fromRow);
        int difference = firstPos - secondPos;
        difference = Math.abs(difference);
        if (difference == 6 || difference == 10 || difference == 15 || difference == 17) {
            return true;
        }
    }
    if (fromPiece.pieceInfo == PieceType::Rook || fromPiece.pieceInfo == PieceType::Queen || fromPiece.pieceInfo == PieceType::Bishop) {
        if ((toRow == fromRow || fromCol == toCol) && (fromPiece.pieceInfo == PieceType::Rook || fromPiece.pieceInfo == PieceType::Queen)) {
            
            /* Check the row */
            if (toRow == fromRow) {
                
                    /* check right */
                    if (toCol > fromCol) {
                        
                        inFront = (iterate _chessBoard where ((toRow == rank) && (file > fromCol) && (piece.pieceInfo != PieceType::None)) order by file asc limit 1);
                        if (inFront[0] as frontItem) {
                            if (toCol > frontItem.file) {
                                piecetype = frontItem.file;
                                return false;
                            }
                        }
                        
                    /* check left */
                    } else {
                        inFront = iterate _chessBoard where (toRow == rank && file < fromCol && piece.pieceInfo != PieceType::None) order by file desc limit 1;
                        if (inFront[0] as frontItem) {
                            if (toCol < frontItem.file) {
                                return false;
                            }
                        }
                    } 
            } else {
                    /* check top */
                    if (toRow < fromRow) {
                        inFront = iterate _chessBoard where (toCol == file && rank < fromRow && piece.pieceInfo != PieceType::None) order by rank desc limit 1;
                        
                        if (inFront[0] as frontItem) {
                            if (toRow < frontItem.rank) {
                                return false;
                            }
                        }
                    } else {
                    /* check bottom */
                    inFront = iterate _chessBoard where (toCol == file && rank > fromRow && piece.pieceInfo != PieceType::None) order by rank asc limit 1;
                    if (inFront[0] as frontItem) {
                        if (toRow > frontItem.rank) {
                            return false;
                        }
                    }
                    }
            }
            /* TODO: Check if it is a king and just go to next step,
                would need to take out bishop check from the else if */
            return true;

        } else {
            if (fromPiece.pieceInfo == PieceType::Bishop || fromPiece.pieceInfo == PieceType::Queen) {
        /* Get the diagonals */
        bool bishopValid = (Math.abs(fromRow - toRow) == Math.abs(fromCol - toCol)); 
        if (bishopValid == false) {
            return false;
        }
        
        int searchAttempt = 1;  
        int difBetween = Math.abs(toRow - fromRow);
        while (searchAttempt < difBetween) {
            if ((iterate _chessBoard where toRow - searchAttempt == rank && toCol - searchAttempt == file && piece.pieceInfo != PieceType::None)[0] as _foundThing) {
                if (posToIndex(fromCol, fromRow) == posToIndex(_foundThing.file- (difBetween - searchAttempt), _foundThing.rank- (difBetween - searchAttempt))) {
                    
                    return false;
                }
            }     
            if ((iterate _chessBoard where toRow + searchAttempt == rank && toCol + searchAttempt == file && piece.pieceInfo != PieceType::None)[0] as _foundThing) {
                if (posToIndex(fromCol, fromRow) == posToIndex(_foundThing.file+ (difBetween - searchAttempt), _foundThing.rank+ (difBetween - searchAttempt))) {
                    return false;
                }
            }
            if ((iterate _chessBoard where toRow - searchAttempt == rank && toCol + searchAttempt == file && piece.pieceInfo != PieceType::None)[0] as _foundThing) {
                if (posToIndex(fromCol, fromRow) == posToIndex(_foundThing.file+ (difBetween - searchAttempt), _foundThing.rank- (difBetween - searchAttempt))) {
                    return false;
                }
            }
            if ((iterate _chessBoard where toRow + searchAttempt == rank && toCol - searchAttempt == file && piece.pieceInfo != PieceType::None)[0] as _foundThing) {
                if (posToIndex(fromCol, fromRow) == posToIndex(_foundThing.file- (difBetween - searchAttempt), _foundThing.rank+ (difBetween - searchAttempt))) {
                    return false;
                }
            }
            
            searchAttempt++;
        } 

            
        return true;
        

    }
        }
        
    } 
    if (fromPiece.pieceInfo == PieceType::King) {
        /* Check diagonals */
        bool diagonalCheck = (fromCol + 1 == toCol && fromRow + 1 == toRow) || (fromCol - 1 == toCol && fromRow -1 == toRow) || (fromCol - 1 == toCol && fromRow + 1 == toRow) || (fromCol + 1 == toCol  && fromRow - 1 == toRow);
        bool adjacentCheck = (fromCol + 1 == toCol && fromRow == toRow) || (fromCol - 1 == toCol && fromRow == toRow) || (fromCol == toCol && fromRow + 1 == toRow) || (fromCol == toCol && fromRow - 1 == toRow);
        if (diagonalCheck || adjacentCheck) {
            return true;
        } else {
            return false;
        }

    }
    return false;
    

}


procedure reset_piece(int row, int col) {

    if ((iterate _chessBoard where rank == row && file == col)[0] as square){
        square.piece.resetPiece();
    }
}

public int checks;
channel<playerSquare> movePiece;

message Nothing {
    int key;
}
channel close(Nothing sum) {
    Document.destroy();
}

procedure validateMove(playerSquare moveThing) -> string {
        int multiplier = currentPlayer == "b" ? -1 : 1;
        bool twice = false;
        bool canTakeFromEnPassant = false;
        checks = 0;
        if ((iterate _chessBoard where rank == moveThing.fromRank && file == moveThing.fromFile)[0] as fromSquare) {
            if ((iterate _chessBoard where rank == moveThing.toRank && file == moveThing.toFile)[0] as toSquare) {
                /* First check if can move by rules */

                Piece fromPiece = fromSquare.piece;
                string currentPlayerColor = fromPiece.color;
                int fromRow = moveThing.fromRank;
                int fromCol = moveThing.fromFile;
                int toRow = moveThing.toRank;
                int toCol = moveThing.toFile;
                
                if ((isMoveValid(fromRow, fromCol, toRow, toCol, fromPiece))) {
                    checks++;
                } else {
                    return "invalid";
                }
                
                
                /* next check if square is empty, add for castling, pawn takes, enpessant*/

                if (toSquare.piece.pieceInfo == PieceType::None) {
                    if (fromPiece.pieceInfo == PieceType::Pawn) {
                        if ((fromCol + 1 == toCol && fromRow - multiplier == toRow )||  (fromCol - 1 == toCol && fromRow - multiplier == toRow)) {
                            return "invalid";
                        }
                        
                    }
                } else {
                    
                    if (toSquare.piece.color == currentPlayerColor) {
                        return "invalid";
                    }
                }
                checks++;
                

                /* check if king is in danger if it moves */

                /* Find the king */
                
                if ((iterate _chessBoard where (piece.pieceInfo == PieceType::King && piece.color == currentPlayerColor) limit 1)[0] as kingSquare) {
                    int kingRow = kingSquare.rank;
                    int kingCol = kingSquare.file;
                    string otherColor = currentPlayerColor == "b" ? "w" : "b";
                    if (fromPiece.pieceInfo == PieceType::King) {
                        kingRow = toRow;
                        kingCol = toCol;
                    }

                    /* Probably more efficient way to do this but for now */
                    string prevColor = toSquare.piece.color;
                    bool prevTwice = toSquare.piece.twice;
                    bool prevCastle = toSquare.piece.canCastle;
                    bool prevPassant = toSquare.piece.canTakeFromEnPassant;
                    PieceType prevType = toSquare.piece.pieceInfo;

                    /* Set piece to the spot */
                    toSquare.piece.setPieceInfo(fromPiece.color, fromPiece.twice, fromPiece.canCastle, fromPiece.canTakeFromEnPassant, fromPiece.pieceInfo);
                    fromSquare.piece.resetPiece();
                   
                    
                    bool valid = true;
                    for (int i = 0; i < 8; i++) {
                        for (int j = 0; j < 8; j++) {
                            if ((iterate _chessBoard where (piece.color == otherColor) && rank == i && file == j)[0] as chessPiece) {
                                if (isMoveValid(chessPiece.rank, chessPiece.file, kingRow, kingCol, chessPiece.piece)) {
                                    valid = false;
                                    break;
                                    
                                }
                                
                            }
                        }
                        if (valid == false) {
                            break;
                        }
                    }
                    
                        /* Set piece back */
                    fromSquare.piece.setPieceInfo(toSquare.piece.color, toSquare.piece.twice, toSquare.piece.canCastle, toSquare.piece.canTakeFromEnPassant, toSquare.piece.pieceInfo);
                    toSquare.piece.setPieceInfo(prevColor, prevTwice, prevCastle, prevPassant, prevType);
                        
                    if (valid == false) {
                        return "invalid";
                    }
                    checks++;
                    
                }


                if (checks == 3) {
                    string validString;
                    /* Update piece if certain condition */
                    return "normal-valid";
                    
                } else {
                    return "invalid";
                }
                
            } 
        }
        return "invalid"; 
        
        
    
} 

procedure updateBoard(playerSquare moveThing) -> bool {
    
    string validity = validateMove(moveThing);
    int fromRow = moveThing.fromRank;
    int fromCol = moveThing.fromFile;
    int toCol = moveThing.toFile;
    int toRow  = moveThing.toRank;

    if (validity == "invalid") {
        return false;
    }

    if ((iterate _chessBoard where rank == fromRow && file == fromCol limit 1)[0] as fromSquare) {
        if ((iterate _chessBoard where rank == toRow && file == toCol limit 1)[0] as toSquare) {
            Piece fromPiece = fromSquare.piece;
            if (fromPiece.pieceInfo == PieceType::Pawn) {
                fromPiece.canTakeFromEnPassant = false;
                if (fromPiece.twice) {
                    fromPiece.twice = false;
                }
                if (Math.abs(fromRow - toRow) == 2) {
                    fromPiece.canTakeFromEnPassant = true;
                }
            
            }
            if (validity == "normal-valid") {
                lastMove = "" + fromRow + "" + fromCol + " " + toRow + "" + toCol;
                toSquare.piece.setPieceInfo(fromPiece.color, fromPiece.twice, fromPiece.canCastle, fromPiece.canTakeFromEnPassant, fromPiece.pieceInfo);
                reset_piece(fromRow, fromCol);
            }   

        }
    }
    /* Check if piece is special */
    /* Get the pieces to and fro */

    return true;



}

procedure kingCanMove(BoardSquare kingSquare) -> bool {
    
        for (int i = -1; i <= 1; i++) {
            
            if (i == 0) {
                continue;
            }
            playerSquare TRBL = {fromRank: kingSquare.rank, fromFile: kingSquare.file ,toFile: kingSquare.file + i, toRank: kingSquare.rank + i};
            playerSquare TLBR = {fromRank: kingSquare.rank, fromFile: kingSquare.file, toFile: kingSquare.file - i, toRank: kingSquare.rank + i};
            playerSquare MRML = {fromRank: kingSquare.rank, fromFile: kingSquare.file, toFile: kingSquare.file , toRank: kingSquare.rank + i};
            playerSquare TMBM = {fromRank: kingSquare.rank, fromFile: kingSquare.file, toFile: kingSquare.file + i, toRank: kingSquare.rank};
            if (validateMove(TRBL) == "normal-valid") {
                    return true;
                }
            if (validateMove(TLBR) == "normal-valid") {
                return true;
            }
            if (validateMove(MRML) == "normal-valid") {
                return true;
            }
            if (validateMove(TMBM) == "normal-valid") {
                return true;
            }
            
        
        
        }
    
    return false;
}

procedure anyPieceCanMakeValidMove(BoardSquare kingSquare) -> bool {
    list<BoardSquare> yourPieces = (iterate _chessBoard where piece.color == kingSquare.piece.color);
    list<BoardSquare> board = (iterate _chessBoard where piece.color != kingSquare.piece.color);
    for (int i = 0; i < yourPieces.size(); i++) {
        if (yourPieces[i] as yourPiece) {
            for (int j = 0; j < board.size(); j++) {
                if (board[j] as boardPiece) {
                    playerSquare tryMove = {fromFile: yourPiece.file, toFile: boardPiece.file, fromRank: yourPiece.rank, toRank: boardPiece.rank};
                    if (validateMove(tryMove) != "invalid") {
                        NONO = ""+yourPiece.file + yourPiece.rank + " " + boardPiece.file + boardPiece.rank;
                        return true;
                    }
                }
            }
        }
        
    }
    
    
    return false;
}

procedure check_if_end() -> string{
    /* To check if a player won, the other king can not have anywhere to go and must be in check */

    /* Find the king */

    if ((iterate _chessBoard where piece.pieceInfo == PieceType::King && piece.color != currentPlayer limit 1)[0] as kingSquare) {
        /* Check if king is checked */
        bool isChecked;
        /* Better to just do a list */
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8;j++) {
                if ((iterate _chessBoard where piece.pieceInfo != PieceType::None && piece.color == currentPlayer && rank == i && file == j limit 1)[0] as tryPiece) {
                    playerSquare tryMove = {fromRank: tryPiece.rank ,toRank: kingSquare.rank, fromFile: tryPiece.file, toFile: kingSquare.file};
                    if (validateMove(tryMove) != "invalid") {
                        isChecked = true;
                    }
                } else {
                    continue;
                }
            }
        }

        if (anyPieceCanMakeValidMove(kingSquare)) {
            return "continue";
        } else {
            if (isChecked) {
                return "win";
            }
            return "draw";
        }
       
        
        
    }
    
    /* First check if it is in check */
    
    return "continue";


    /* If king is checked, first check if king can move */
    /* If king can't move, then check if taking a check pieced can let king move */
    /* Do this for all pieces checking the king, and if NONE of the moves are valid, then return true */
    
    /* The validate move seems to be more useful here!*/

    /* For draw, if king is not checked and none of the pieces can move, then draw */
}
#start {
    gameState = "game";
    transition #turn;
}

#turn {
    /* Soon change so that it must be from a certain list of the possible locations */
    future<playerSquare> chosenSquare = movePiece.fetch(currentPlayer == "w" ? playerW : playerB);
    playerSquare squareUnwrapped = chosenSquare.await();
    
    if (updateBoard(squareUnwrapped)) {
        /* Check if player won */
        string willEnd = check_if_end();
        if (willEnd != "continue") {
            if (willEnd == "draw") {
                gameState = "draw";
            } else {
                gameState = "win";
            }
            transition #end;
            return;
        }
        currentPlayer = currentPlayer == "w" ? "b" : "w";
    }

    transition #turn;

}

#end {
    return;
}

@connected {
    if (playerW == @no_one) {
        playerW = @who;
        if (playerB != @no_one) {
            transition #start;
        }
        return true;
    }
    if (playerB == @no_one) {
        playerB = @who;
        if (playerW != @no_one) {
            transition #start;
        }
        return true;
    }

    return false;
}

@disconnected {
    if (playerW == @who || playerB == @who) {
        Document.destroy();
    }
}
